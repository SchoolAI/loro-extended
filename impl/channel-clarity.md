# Channel Type Clarity Refactoring

## Overview

This document outlines a refactoring to make channel states explicit through progressive type refinement, eliminating impossible states and removing redundant connection tracking.

## Problem Statement

The current channel type system has several issues:

1. **Implicit State Progression**: Channels progress through three distinct states (generated → connected → established), but the type system doesn't make this clear
2. **Redundant State Tracking**: `connectionState` field duplicates information already implicit in channel lifecycle
3. **Impossible States**: Current types allow combinations that shouldn't exist (e.g., `onReceive` without `channelId`)
4. **Peer Data Duplication**: Peer identity details are embedded in channels, but we're moving toward tracking peers as first-class entities

## Current State

### Current Type Hierarchy

```typescript
// Base channel from adapter.generate()
type BaseChannel = ChannelMeta & ChannelActions

// Channel after registration with synchronizer
type Channel = BaseChannel & ChannelIdentity & {
  onReceive: (msg: ChannelMsg) => void
}

// ChannelIdentity contains both channelId and peer state
type ChannelIdentity = {
  channelId: ChannelId
  peer: { state: "unestablished" } | { state: "established"; identity: PeerIdentityDetails }
  connectionState: ChannelConnectionState  // ← Redundant
}
```

### Current Lifecycle

1. **Adapter creates** → `BaseChannel` (via `generate()`)
2. **ChannelDirectory registers** → `Channel` with `peer.state = "unestablished"`
3. **Establish handshake** → `Channel` with `peer.state = "established"`

## Proposed Solution

### New Type Hierarchy

```typescript
// 1. Generated by adapter.generate()
export type GeneratedChannel = ChannelMeta & ChannelActions

// 2. Connected to synchronizer (can send/receive)
export type ConnectedChannel = GeneratedChannel & {
  channelId: ChannelId
  onReceive: (msg: ChannelMsg) => void
}

// 3. Established with peer (knows which peer)
export type Channel = ConnectedChannel & {
  peerId: PeerId
}
```

### Type Guards

```typescript
export function isEstablished(channel: ConnectedChannel): channel is Channel {
  return 'peerId' in channel
}
```

### Key Changes

1. **Progressive Refinement**: Each type builds on the previous, making the progression explicit
2. **Remove `connectionState`**: Channel existence in model implies connection
3. **Remove `peer` object**: Replace with simple `peerId` reference
4. **Peer as First-Class Entity**: Peers will be tracked separately in synchronizer model

## Implementation Plan

### Phase 1: Type Definitions

**File**: `packages/repo/src/channel.ts`

1. Define new type hierarchy:
   - `GeneratedChannel`
   - `ConnectedChannel`
   - `Channel` (with `peerId`)
2. Add type guard: `isEstablished()`
3. Remove `ChannelIdentity` type
4. Remove `ChannelConnectionState` type
5. Update `GenerateFn<G>` return type to `GeneratedChannel`

### Phase 2: Adapter Layer

**File**: `packages/repo/src/adapter/adapter.ts`

1. Update imports:
   - Replace `BaseChannel` → `GeneratedChannel`
   - Add `ConnectedChannel` import
2. Update method signatures:
   - `generate()`: returns `GeneratedChannel`
   - `addChannel()`: returns `ConnectedChannel`
   - `removeChannel()`: returns `ConnectedChannel | undefined`
3. Update `AdapterHooks` type to use `ConnectedChannel`
4. Update lifecycle state types to use `ConnectedChannel`
5. Update `_initialize()` hooks parameter types

### Phase 3: Channel Directory

**File**: `packages/repo/src/channel-directory.ts`

1. Update `create()` method:
   - Remove `connectionState: "connecting"` initialization
   - Remove `peer: { state: "unestablished" }` initialization
   - Return type: `ConnectedChannel`
2. Update internal `channels` map type to `Map<ChannelId, ConnectedChannel>`
3. Update method return types to use `ConnectedChannel`

### Phase 4: Synchronizer Program

**File**: `packages/repo/src/synchronizer-program.ts`

#### Remove Connection State Mutations

1. **Line 135**: Remove `msg.channel.connectionState = "connected"`
2. **Lines 321-323**: Remove `channel-disconnected` handler
3. **Lines 328-338**: Remove `channel-error` handler

#### Update Peer Establishment

1. **Lines 388-391** (`establish-request`):
   ```typescript
   // OLD: channel.peer = { state: "established", identity: ... }
   // NEW: Add peerId to channel, track peer separately
   const peerId = generatePeerId() // or extract from identity
   Object.assign(channel, { peerId })
   // Store peer details in model.peers map
   ```

2. **Lines 429-432** (`establish-response`):
   ```typescript
   // Same pattern as establish-request
   ```

#### Remove Obsolete Message Types

Remove from `SynchronizerMessage` union (lines 44-47):
- `synchronizer/channel-disconnected`
- `synchronizer/channel-error`

#### Update Type References

Replace `Channel` with `ConnectedChannel` where appropriate:
- Function parameters that work with pre-established channels
- Keep `Channel` for contexts requiring established channels

### Phase 5: Synchronizer

**File**: `packages/repo/src/synchronizer.ts`

#### Simplify Validation

**Lines 331-352** - Replace `#validateChannelForSend()`:

```typescript
// OLD:
if (channel.connectionState !== "connected") {
  this.logger.warn(`Cannot send: channel ${channelId} not connected`)
  return false
}
if (channel.peer.state !== "established") {
  this.logger.warn(`Cannot send: channel ${channelId} peer not established`)
  return false
}

// NEW:
if (!isEstablished(channel)) {
  this.logger.warn(`Cannot send: channel ${channelId} not established`)
  return false
}
```

#### Update Model Type

Add peers map to `SynchronizerModel`:
```typescript
export type SynchronizerModel = {
  identity: PeerIdentityDetails
  documents: Map<DocId, DocState>
  channels: Map<ChannelId, ConnectedChannel>  // May be Channel after establishment
  peers: Map<PeerId, PeerIdentityDetails>     // NEW
}
```

### Phase 6: Types

**File**: `packages/repo/src/types.ts`

1. Add `PeerId` type (already exists)
2. Remove `ChannelConnectionState` type (lines 79-83)
3. Update any references to removed types

### Phase 7: Tests

#### Update Test Helpers

**File**: `packages/repo/src/synchronizer-program.test.ts`

Update `createMockChannel()` (lines 23-35):
```typescript
function createMockChannel(overrides: Partial<ConnectedChannel> = {}): ConnectedChannel {
  return {
    channelId: 1,
    kind: "network",
    adapterId: "test-adapter",
    send: vi.fn(),
    stop: vi.fn(),
    onReceive: vi.fn(),
    ...overrides,
  }
}
```

#### Remove Obsolete Assertions

Remove assertions about `connectionState`:
- `synchronizer-program.test.ts:107`
- `synchronizer.test.ts:205`

#### Update Establishment Tests

Update tests that check `peer.state`:
```typescript
// OLD: expect(channel.peer.state).toBe("established")
// NEW: expect(isEstablished(channel)).toBe(true)
```

### Phase 8: Documentation

Update documentation in:
- `packages/repo/src/adapter/adapter.md`
- `packages/repo/src/synchronizer.md`
- `packages/repo/src/doc-handle.md`

## Benefits

### 1. Type Safety

**Before**: TypeScript allows impossible states
```typescript
// Could theoretically have onReceive without channelId
const channel: Channel = { ...baseChannel, onReceive: fn }
```

**After**: Progressive types prevent impossible states
```typescript
// ConnectedChannel requires both channelId AND onReceive
const channel: ConnectedChannel = { ...generated, channelId, onReceive }
```

### 2. Simplified State Management

**Before**: Three places track connection state
- `connectionState` field
- Channel existence in model
- Peer establishment state

**After**: Single source of truth
- Channel in model = connected
- `peerId` present = established

### 3. Clearer Semantics

**Before**: Ambiguous what "connected" means
```typescript
if (channel.connectionState === "connected" && channel.peer.state === "established")
```

**After**: Clear type-based distinction
```typescript
if (isEstablished(channel))
```

### 4. Reduced Complexity

**Removed**:
- `ChannelConnectionState` type
- `connectionState` field
- `peer.state` discriminator
- 2 message types (`channel-disconnected`, `channel-error`)
- 3 state mutation sites

**Added**:
- 1 type guard function
- Clearer type progression

## Migration Strategy

### Backward Compatibility

This is a **breaking change** for:
1. Code accessing `channel.connectionState`
2. Code accessing `channel.peer.state` or `channel.peer.identity`
3. Adapter implementations using `BaseChannel` type name

### Migration Path

1. **Internal refactoring first**: Update all internal code
2. **Update examples**: Ensure examples work with new types
3. **Version bump**: This requires a minor version bump (breaking change)
4. **Migration guide**: Document how to update adapter implementations

### Rollout

1. Create feature branch
2. Implement changes in order (Phase 1-8)
3. Run full test suite after each phase
4. Update examples and documentation
5. Merge to main with version bump

## Testing Strategy

### Unit Tests

- Test type guards work correctly
- Test channel lifecycle transitions
- Test validation logic with new types

### Integration Tests

- Test adapter channel creation
- Test establish handshake flow
- Test message sending with established channels

### E2E Tests

- Run existing e2e tests (todo-app)
- Verify no regressions in sync behavior

## Risks and Mitigations

### Risk 1: Breaking Existing Adapters

**Mitigation**: 
- Provide clear migration guide
- Update all built-in adapters
- Version bump signals breaking change

### Risk 2: Missed References

**Mitigation**:
- TypeScript will catch most issues
- Comprehensive test coverage
- Search codebase for removed types

### Risk 3: Subtle Behavior Changes

**Mitigation**:
- Careful review of validation logic
- Test edge cases (disconnect during establish)
- Monitor for issues in e2e tests

## Success Criteria

1. ✅ All tests pass
2. ✅ No TypeScript errors
3. ✅ E2E tests demonstrate correct sync behavior
4. ✅ Code is simpler and more maintainable
5. ✅ Type system prevents impossible states
6. ✅ Documentation is updated

## Future Work

### Peer Management

Once this refactoring is complete, we can:
1. Add `peers: Map<PeerId, PeerDetails>` to synchronizer model
2. Track peer metadata separately from channels
3. Support multiple channels per peer
4. Implement peer-based permissions

### Enhanced Type Safety

Future improvements could include:
1. Branded types for IDs (nominal typing)
2. State machine types for channel lifecycle
3. Effect types for async operations

## Conclusion

This refactoring makes channel states explicit through progressive type refinement, eliminates redundant state tracking, and prepares the codebase for peer-centric architecture. The changes are breaking but provide significant improvements in type safety, code clarity, and maintainability.